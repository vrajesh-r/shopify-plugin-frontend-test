"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.maskValue = exports.getElementInputValue = exports.makeUrlAbsolute = exports.makeSrcsetUrlsAbsolute = exports.makeStylesheetUrlsAbsolute = exports.transformAttribute = exports.setSerializedNode = exports.getSerializedNodeId = exports.nodeAndAncestorsHaveSerializedNode = exports.hasSerializedNode = void 0;
var browser_core_1 = require("@datadog/browser-core");
var privacy_1 = require("./privacy");
function hasSerializedNode(node) {
    return '__sn' in node;
}
exports.hasSerializedNode = hasSerializedNode;
function nodeAndAncestorsHaveSerializedNode(node) {
    var current = node;
    while (current) {
        if (!hasSerializedNode(current)) {
            return false;
        }
        current = current.parentNode;
    }
    return true;
}
exports.nodeAndAncestorsHaveSerializedNode = nodeAndAncestorsHaveSerializedNode;
function getSerializedNodeId(node) {
    return hasSerializedNode(node) ? node.__sn.id : undefined;
}
exports.getSerializedNodeId = getSerializedNodeId;
function setSerializedNode(node, serializeNode) {
    ;
    node.__sn = serializeNode;
}
exports.setSerializedNode = setSerializedNode;
function transformAttribute(doc, name, value) {
    if (!value) {
        return value;
    }
    if (name === 'src' || name === 'href') {
        return makeUrlAbsolute(value, doc.location.href);
    }
    if (name === 'srcset') {
        return makeSrcsetUrlsAbsolute(value, doc.location.href);
    }
    if (name === 'style') {
        return makeStylesheetUrlsAbsolute(value, doc.location.href);
    }
    return value;
}
exports.transformAttribute = transformAttribute;
var URL_IN_CSS_REF = /url\((?:(')([^']*)'|(")([^"]*)"|([^)]*))\)/gm;
var ABSOLUTE_URL = /^[A-Za-z]+:|^\/\//;
var DATA_URI = /^data:.*,/i;
function makeStylesheetUrlsAbsolute(cssText, baseUrl) {
    return cssText.replace(URL_IN_CSS_REF, function (origin, quote1, path1, quote2, path2, path3) {
        var filePath = path1 || path2 || path3;
        if (!filePath || ABSOLUTE_URL.test(filePath) || DATA_URI.test(filePath)) {
            return origin;
        }
        var maybeQuote = quote1 || quote2 || '';
        return "url(" + maybeQuote + makeUrlAbsolute(filePath, baseUrl) + maybeQuote + ")";
    });
}
exports.makeStylesheetUrlsAbsolute = makeStylesheetUrlsAbsolute;
var SRCSET_URLS = /(^\s*|,\s*)([^\s,]+)/g;
function makeSrcsetUrlsAbsolute(attributeValue, baseUrl) {
    return attributeValue.replace(SRCSET_URLS, function (_, prefix, url) { return "" + prefix + makeUrlAbsolute(url, baseUrl); });
}
exports.makeSrcsetUrlsAbsolute = makeSrcsetUrlsAbsolute;
function makeUrlAbsolute(url, baseUrl) {
    try {
        return browser_core_1.buildUrl(url.trim(), baseUrl).href;
    }
    catch (_) {
        return url;
    }
}
exports.makeUrlAbsolute = makeUrlAbsolute;
/**
 * Get the element "value" to be serialized as an attribute or an input update record. It respects
 * the input privacy mode of the element. An 'ancestorInputPrivacyMode' can be provided (if known)
 * to avoid iterating over the element ancestors when looking for the input privacy mode.
 */
function getElementInputValue(element, ancestorInputPrivacyMode) {
    var tagName = element.tagName;
    if (tagName === 'OPTION' || tagName === 'SELECT') {
        // Always use the option and select value, as they are useful to display the currently selected
        // option during replay. They can still be hidden via the "hidden" privacy attribute or class
        // name.
        return element.value;
    }
    if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {
        return;
    }
    var value = element.value;
    var type = element.type;
    if (type === 'button' || type === 'submit' || type === 'reset') {
        // Always use button-like element values, as they are used during replay to display their label.
        // They can still be hidden via the "hidden" privacy attribute or class name.
        return value;
    }
    var inputPrivacyMode = ancestorInputPrivacyMode
        ? privacy_1.getNodeInputPrivacyMode(element, ancestorInputPrivacyMode)
        : privacy_1.getNodeOrAncestorsInputPrivacyMode(element);
    if (inputPrivacyMode === 2 /* IGNORED */ ||
        // Never use the radio and checkbox value, as they are not useful during replay.
        type === 'radio' ||
        type === 'checkbox') {
        return;
    }
    return inputPrivacyMode === 3 /* MASKED */ ? maskValue(value) : value;
}
exports.getElementInputValue = getElementInputValue;
function maskValue(value) {
    return value.replace(/./g, '*');
}
exports.maskValue = maskValue;
//# sourceMappingURL=serializationUtils.js.map