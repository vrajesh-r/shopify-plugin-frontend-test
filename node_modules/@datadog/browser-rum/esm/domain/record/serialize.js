import { __assign } from "tslib";
import { PRIVACY_ATTR_NAME, PRIVACY_ATTR_VALUE_HIDDEN } from '../../constants';
import { getNodeInputPrivacyMode, nodeShouldBeHidden } from './privacy';
import { NodeType, } from './types';
import { makeStylesheetUrlsAbsolute, getSerializedNodeId, setSerializedNode, transformAttribute, getElementInputValue, } from './serializationUtils';
import { forEach } from './utils';
export function serializeDocument(document) {
    // We are sure that Documents are never ignored, so this function never returns null
    return serializeNodeWithId(document, {
        document: document,
        ancestorInputPrivacyMode: 1 /* NONE */,
    });
}
export function serializeNodeWithId(node, options) {
    var serializedNode = serializeNode(node, options);
    if (!serializedNode) {
        return null;
    }
    // Try to reuse the previous id
    var id = getSerializedNodeId(node) || generateNextId();
    var serializedNodeWithId = serializedNode;
    serializedNodeWithId.id = id;
    setSerializedNode(node, serializedNodeWithId);
    if (options.serializedNodeIds) {
        options.serializedNodeIds.add(id);
    }
    return serializedNodeWithId;
}
function serializeNode(node, options) {
    switch (node.nodeType) {
        case node.DOCUMENT_NODE:
            return serializeDocumentNode(node, options);
        case node.DOCUMENT_TYPE_NODE:
            return serializeDocumentTypeNode(node);
        case node.ELEMENT_NODE:
            return serializeElementNode(node, options);
        case node.TEXT_NODE:
            return serializeTextNode(node, options);
        case node.CDATA_SECTION_NODE:
            return serializeCDataNode();
    }
}
function serializeDocumentNode(document, options) {
    return {
        type: NodeType.Document,
        childNodes: serializeChildNodes(document, options),
    };
}
function serializeDocumentTypeNode(documentType) {
    return {
        type: NodeType.DocumentType,
        name: documentType.name,
        publicId: documentType.publicId,
        systemId: documentType.systemId,
    };
}
function serializeElementNode(element, options) {
    var _a;
    var tagName = getValidTagName(element.tagName);
    var isSVG = isSVGElement(element) || undefined;
    if (shouldIgnoreElement(element)) {
        return;
    }
    if (nodeShouldBeHidden(element)) {
        var _b = element.getBoundingClientRect(), width = _b.width, height = _b.height;
        return {
            type: NodeType.Element,
            tagName: tagName,
            attributes: (_a = {
                    id: element.id,
                    class: element.className,
                    rr_width: width + "px",
                    rr_height: height + "px"
                },
                _a[PRIVACY_ATTR_NAME] = PRIVACY_ATTR_VALUE_HIDDEN,
                _a),
            childNodes: [],
            isSVG: isSVG,
        };
    }
    var attributes = {};
    for (var _i = 0, _c = Array.from(element.attributes); _i < _c.length; _i++) {
        var _d = _c[_i], name_1 = _d.name, value_1 = _d.value;
        // Never take those attributes into account, as they will be conditionally set below.
        if (name_1 === 'value' || name_1 === 'selected' || name_1 === 'checked') {
            continue;
        }
        attributes[name_1] = transformAttribute(options.document, name_1, value_1);
    }
    // remote css
    if (tagName === 'link') {
        var stylesheet = Array.from(options.document.styleSheets).find(function (s) { return s.href === element.href; });
        var cssText = getCssRulesString(stylesheet);
        if (cssText) {
            delete attributes.rel;
            delete attributes.href;
            attributes._cssText = makeStylesheetUrlsAbsolute(cssText, stylesheet.href);
        }
    }
    // dynamic stylesheet
    if (tagName === 'style' &&
        element.sheet &&
        // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element
        !(element.innerText || element.textContent || '').trim().length) {
        var cssText = getCssRulesString(element.sheet);
        if (cssText) {
            attributes._cssText = makeStylesheetUrlsAbsolute(cssText, location.href);
        }
    }
    // form fields
    var value = getElementInputValue(element, options.ancestorInputPrivacyMode);
    if (value) {
        attributes.value = value;
    }
    if (tagName === 'option') {
        var selectElement = element.parentElement;
        if (element.value === selectElement.value) {
            attributes.selected = element.selected;
        }
    }
    if (tagName === 'input' && element.checked) {
        attributes.checked = true;
    }
    // media elements
    if (tagName === 'audio' || tagName === 'video') {
        attributes.rr_mediaState = element.paused ? 'paused' : 'played';
    }
    // scroll
    if (element.scrollLeft) {
        attributes.rr_scrollLeft = Math.round(element.scrollLeft);
    }
    if (element.scrollTop) {
        attributes.rr_scrollTop = Math.round(element.scrollTop);
    }
    var childNodes;
    if (element.childNodes.length) {
        var childNodesSerializationOptions = options;
        // We should not create a new object systematically as it could impact performances. Try to reuse
        // the same object as much as possible, and clone it only if we need to.
        if (tagName === 'head') {
            childNodesSerializationOptions = __assign(__assign({}, childNodesSerializationOptions), { ignoreWhiteSpace: true });
        }
        var inputPrivacyMode = getNodeInputPrivacyMode(element, options.ancestorInputPrivacyMode);
        if (inputPrivacyMode !== options.ancestorInputPrivacyMode) {
            childNodesSerializationOptions = __assign(__assign({}, childNodesSerializationOptions), { ancestorInputPrivacyMode: inputPrivacyMode });
        }
        childNodes = serializeChildNodes(element, childNodesSerializationOptions);
    }
    else {
        childNodes = [];
    }
    return {
        type: NodeType.Element,
        tagName: tagName,
        attributes: attributes,
        childNodes: childNodes,
        isSVG: isSVG,
    };
}
function shouldIgnoreElement(element) {
    if (element.nodeName === 'SCRIPT') {
        return true;
    }
    if (element.nodeName === 'LINK') {
        var relAttribute = getLowerCaseAttribute('rel');
        return (
        // Scripts
        (relAttribute === 'preload' && getLowerCaseAttribute('as') === 'script') ||
            // Favicons
            relAttribute === 'shortcut icon' ||
            relAttribute === 'icon');
    }
    if (element.nodeName === 'META') {
        var nameAttribute = getLowerCaseAttribute('name');
        var relAttribute = getLowerCaseAttribute('rel');
        var propertyAttribute = getLowerCaseAttribute('property');
        return (
        // Favicons
        /^msapplication-tile(image|color)$/.test(nameAttribute) ||
            nameAttribute === 'application-name' ||
            relAttribute === 'icon' ||
            relAttribute === 'apple-touch-icon' ||
            relAttribute === 'shortcut icon' ||
            // Description
            nameAttribute === 'keywords' ||
            nameAttribute === 'description' ||
            // Social
            /^(og|twitter|fb):/.test(propertyAttribute) ||
            /^(og|twitter):/.test(nameAttribute) ||
            nameAttribute === 'pinterest' ||
            // Robots
            nameAttribute === 'robots' ||
            nameAttribute === 'googlebot' ||
            nameAttribute === 'bingbot' ||
            // Http headers. Ex: X-UA-Compatible, Content-Type, Content-Language, cache-control,
            // X-Translated-By
            element.hasAttribute('http-equiv') ||
            // Authorship
            nameAttribute === 'author' ||
            nameAttribute === 'generator' ||
            nameAttribute === 'framework' ||
            nameAttribute === 'publisher' ||
            nameAttribute === 'progid' ||
            /^article:/.test(propertyAttribute) ||
            /^product:/.test(propertyAttribute) ||
            // Verification
            nameAttribute === 'google-site-verification' ||
            nameAttribute === 'yandex-verification' ||
            nameAttribute === 'csrf-token' ||
            nameAttribute === 'p:domain_verify' ||
            nameAttribute === 'verify-v1' ||
            nameAttribute === 'verification' ||
            nameAttribute === 'shopify-checkout-api-token');
    }
    function getLowerCaseAttribute(name) {
        return (element.getAttribute(name) || '').toLowerCase();
    }
    return false;
}
function serializeTextNode(text, options) {
    // The parent node may not be a html element which has a tagName attribute.
    // So just let it be undefined which is ok in this use case.
    var parentTagName = text.parentNode && text.parentNode.tagName;
    var textContent = text.textContent || '';
    var isStyle = parentTagName === 'STYLE' ? true : undefined;
    if (isStyle) {
        textContent = makeStylesheetUrlsAbsolute(textContent, location.href);
    }
    else if (options.ignoreWhiteSpace && !textContent.trim()) {
        return;
    }
    return {
        type: NodeType.Text,
        textContent: textContent,
        isStyle: isStyle,
    };
}
function serializeCDataNode() {
    return {
        type: NodeType.CDATA,
        textContent: '',
    };
}
function serializeChildNodes(node, options) {
    var result = [];
    forEach(node.childNodes, function (childNode) {
        var serializedChildNode = serializeNodeWithId(childNode, options);
        if (serializedChildNode) {
            result.push(serializedChildNode);
        }
    });
    return result;
}
var nextId = 1;
function generateNextId() {
    return nextId++;
}
var TAG_NAME_REGEX = /[^a-z1-6-_]/;
function getValidTagName(tagName) {
    var processedTagName = tagName.toLowerCase().trim();
    if (TAG_NAME_REGEX.test(processedTagName)) {
        // if the tag name is odd and we cannot extract
        // anything from the string, then we return a
        // generic div
        return 'div';
    }
    return processedTagName;
}
function getCssRulesString(s) {
    try {
        var rules = s.rules || s.cssRules;
        return rules ? Array.from(rules).map(getCssRuleString).join('') : null;
    }
    catch (error) {
        return null;
    }
}
function getCssRuleString(rule) {
    return isCSSImportRule(rule) ? getCssRulesString(rule.styleSheet) || '' : rule.cssText;
}
function isCSSImportRule(rule) {
    return 'styleSheet' in rule;
}
function isSVGElement(el) {
    return el.tagName === 'svg' || el instanceof SVGElement;
}
//# sourceMappingURL=serialize.js.map