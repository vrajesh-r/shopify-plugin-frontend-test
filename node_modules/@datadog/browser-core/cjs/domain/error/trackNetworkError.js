"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trackNetworkError = void 0;
var fetchProxy_1 = require("../../browser/fetchProxy");
var xhrProxy_1 = require("../../browser/xhrProxy");
var error_1 = require("../../tools/error");
var utils_1 = require("../../tools/utils");
function trackNetworkError(configuration, errorObservable, trackAbortedRequests) {
    if (trackAbortedRequests === void 0) { trackAbortedRequests = true; }
    xhrProxy_1.startXhrProxy().onRequestComplete(function (context) { return handleCompleteRequest(utils_1.RequestType.XHR, context); });
    fetchProxy_1.startFetchProxy().onRequestComplete(function (context) { return handleCompleteRequest(utils_1.RequestType.FETCH, context); });
    function handleCompleteRequest(type, request) {
        if (!configuration.isIntakeUrl(request.url) &&
            (trackAbortedRequests || !request.isAborted) &&
            (isRejected(request) || isServerError(request))) {
            errorObservable.notify({
                message: format(type) + " error " + request.method + " " + request.url,
                resource: {
                    method: request.method,
                    statusCode: request.status,
                    url: request.url,
                },
                source: error_1.ErrorSource.NETWORK,
                stack: truncateResponseText(request.responseText, configuration) || 'Failed to load',
                startClocks: request.startClocks,
            });
        }
    }
    return {
        stop: function () {
            xhrProxy_1.resetXhrProxy();
            fetchProxy_1.resetFetchProxy();
        },
    };
}
exports.trackNetworkError = trackNetworkError;
function isRejected(request) {
    return request.status === 0 && request.responseType !== 'opaque';
}
function isServerError(request) {
    return request.status >= 500;
}
function truncateResponseText(responseText, configuration) {
    if (responseText && responseText.length > configuration.requestErrorResponseLengthLimit) {
        return responseText.substring(0, configuration.requestErrorResponseLengthLimit) + "...";
    }
    return responseText;
}
function format(type) {
    if (utils_1.RequestType.XHR === type) {
        return 'XHR';
    }
    return 'Fetch';
}
//# sourceMappingURL=trackNetworkError.js.map